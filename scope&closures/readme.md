# 总结

## 作用域

js 是编译型语言，在执行前几微妙内编译，（==JIT？==）
编译过程：

- 词法分析
- 解析（AST 抽象语法树）
- 代码生成

赋值操作左边为 LHS，右边为 RHS（Right-hand Side）

赋值操作包括：= 、 函数参数赋值

LHS：从作用域里找到赋值的目标（当前层找不到就向顶层继续找）

RHS：找到赋值的值（源）

==找不到 RHS 会抛出 **ReferenceError**；

找到了 RHS 但是用这个值做了些不能做的事情会抛出 **TypeError** （比如将一个非函数的值作为函数运行，或者引用 null 或者 undefined 值的属性）

## 复习

作用域是一组规则，它决定了一个变量（标识符）在哪里和如何被查找。这种查询也许是为了向这个变量赋值，这时变量是一个 LHS（左手边）引用，或者是为取得它的值，这时变量是一个 RHS（右手边）引用。

LHS 引用得自赋值操作。作用域 相关的赋值可以通过 = 操作符发生，也可以通过向函数参数传递（赋予）参数值发生。

JavaScript 引擎 在执行代码之前首先会编译它，因此，它将 var a = 2; 这样的语句分割为两个分离的步骤：

首先，var a 在当前 作用域 中声明。这是在最开始，代码执行之前实施的。

稍后，a = 2 查找这个变量（LHS 引用），并且如果找到就向它赋值。

LHS 和 RHS 引用查询都从当前执行中的 作用域 开始，如果有需要（也就是，它们在这里没能找到它们要找的东西），它们会在嵌套的 作用域 中一路向上，一次一个作用域（层）地查找这个标识符，直到它们到达全局作用域（顶层）并停止，既可能找到也可能没找到。

未被满足的 RHS 引用会导致 ReferenceError 被抛出。未被满足的 LHS 引用会导致一个自动的，隐含地创建的同名全局变量（如果不是“Strict 模式”[^note-strictmode]），或者一个 ReferenceError（如果是“Strict 模式”[^note-strictmode]）。

### 小测验

```javascript
function foo(a) {
  var b = a;
  return a + b;
}
```

var c = foo( 2 );
找出所有的 LHS 查询（有 3 处！）。

c = .., a = 2（隐含的参数赋值）和 b = ..

找出所有的 RHS 查询（有 4 处！）。

foo(2.., = a;, a + .. 和 .. + b

## 词法作用域

词法作用域意味着作用域是由编写时函数被声明的位置的决策定义的。编译器的词法分析阶段实质上可以知道所有的标识符是在哪里和如何声明的，并如此在执行期间预测它们将如何被查询。

**在 JavaScript 中有两种机制可以“欺骗”词法作用域：eval(..) 和 with。**前者可以通过对一个拥有一个或多个声明的“代码”字符串进行求值，来（在运行时）修改现存的词法作用域。后者实质上是通过将一个对象引用看作一个“作用域”，并将这个对象的属性看作作用域中的标识符，（同样，也是在运行时）创建一个全新的词法作用域。

这些机制的缺点是，它压制了 引擎 在作用域查询上进行编译期优化的能力，因为 引擎 不得不悲观地假定这样的优化是无效的。这两种特性的结果就是代码 将 会运行的更慢。不要使用它们。

## 函数与块级作用域

函数内部作用域是单独的
所有可以用 iife 构建块级作用域

**匿名函数是有风险的，建议一直对函数命名**。

- 在栈轨迹上匿名函数没有有用的名称可以表示，这可能会使得调试更加困难。

- 没有名称的情况下，如果这个函数需要为了递归等目的引用它自己，那么就需要很不幸地使用 被废弃的 arguments.callee 引用。另一个需要自引用的例子是，当一个事件处理器函数在被触发后想要把自己解除绑定。

- 匿名函数省略的名称经常对提供更易读/易懂的代码很有帮助。一个描述性的名称可以帮助代码自解释。

with
我们在第二章中学习了 with。虽然它是一个使人皱眉头的结构，但它确实是一个（一种形式的）块儿作用域的例子，**它从对象中创建的作用域仅存在于这个 with 语句的生命周期中，而不在外围作用域中**。

try/catch
一个鲜为人知的事实是，JavaScript 在 ES3 中明确指出在 try/catch 的 catch 子句中声明的变量，是属于 catch 块儿的块儿作用域的。

在 JavaScript 中函数是最常见的作用域单位。在另一个函数内部声明的变量和函数，实质上对任何外围“作用域”都是“隐藏的”，这是优秀软件的一个有意的设计原则。

但是函数绝不是唯一的作用域单位。块儿作用域指的是这样一种想法：变量和函数可以属于任意代码块儿（一般来说，就是任意的 { .. }），而不是仅属于外围的函数。

从 ES3 开始，**try/catch 结构在 catch 子句上拥有块儿作用域**。

在 ES6 中，引入了 let 关键字（var 关键字的表兄弟）允许在任意代码块中声明变量。if (..) { let a = 2; } 将会声明变量 a，而它实质上劫持了 if 的 { .. } 块儿的作用域，并将自己附着在这里。

虽然有些人对此深信不疑，但是块儿作用域不应当被认为是 var 函数作用域的一个彻头彻尾的替代品。两种机能是共存的，而且开发者们可以并且应当同时使用函数作用域和块儿作用域技术 —— 在它们各自可以产生更好，更易读/易维护代码的地方。

## 提升

函数声明：function FOO(){}
函数表达式：FOO = function bar(){}

**函数声明会提升，函数变量不会
函数声明先于变量声明被提升**

我们可能被诱导而将 var a = 2 看作是一个语句，但是 JavaScript 引擎 可不这么看。它将 var a 和 a = 2 看作两个分离的语句，第一个是编译期的任务，而第二个是执行时的任务。

这将导致在一个作用域内的所有声明，不论它们出现在何处，都会在代码本身被执行前 首先 被处理。你可以将它可视化为声明（变量与函数）被“移动”到它们各自的作用域顶部，这就是我们所说的“提升”。

声明本身会被提升，但不是赋值，即便是函数表达式的赋值，也 不会 被提升。

要小心重复声明，特别是将一般的变量声明和函数声明混在一起 —— 如果你这么做的话，危险就在眼前！

```javascript
function foo() {
  console.log( 1 );
}
foo(); // 2
function foo() {
  console.log( 2 );
};
//---------------------------------
function foo() {
  console.log( 1 );
}
var foo = function() {
  console.log( 2 );
};
foo(); // 2
//---------------------------------
function foo() {
  console.log( 1 );
}
foo(); // 1
var foo = function() {
  console.log( 2 );
};
//----------------------------------
foo(); // 1
function foo() {
  console.log( 1 );
}
var foo = function() {
  console.log( 2 );
};
//----------------------------------
foo(); // 3
function foo() {
  console.log( 1 );
}
var foo = function() {
  console.log( 2 );
};
function foo() {
  console.log( 3 );
}
```

## 作用域闭包

> <font color="red">**闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。**</font>

实质上 无论何时何地 只要你将函数作为头等的值看待并将它们传来传去的话，你就可能看到这些函数行使闭包。计时器、事件处理器、Ajax 请求、跨窗口消息、web worker、或者任何其他的异步（或同步！）任务，当你传入一个 回调函数，你就在它周围悬挂了一些闭包！

感觉只要这个函数拥有这个函数作用域之外的值，就可能形成闭包

**闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。**

## 模块

如果我们不能小心地识别它们和它们的工作方式，闭包可能会绊住我们，例如在循环中。但它们也是一种极其强大的工具，以各种形式开启了像 模块 这样的模式。

模块要求两个关键性质：1）一个被调用的外部包装函数，来创建外围作用域。2）这个包装函数的返回值必须包含至少一个内部函数的引用，这个函数才拥有包装函数内部作用域的闭包。
